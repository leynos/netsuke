# ADR: Replace `cucumber-rs` with `rstest-bdd` for behavioural tests

## Status

Accepted – plan recorded on 18 November 2025 to guide the migration to
`rstest-bdd` v0.3.2. Updated on 21 December 2025 with key differences and
migration feedback for rstest-bdd developers.

## Context and problem statement

Behavioural coverage currently depends on `cucumber-rs` via the dedicated
`tests/cucumber.rs` runner. The suite relies on a bespoke `CliWorld` struct,
Tokio-specific bootstrapping, and a separate test target declared under
`[[test]]` in `Cargo.toml`. This isolates behaviour-driven development (BDD)
from the rest of the Rust test ecosystem, duplicates fixture plumbing that is
already provided by `rstest`, prevents parallel execution with the unit tests,
and keeps CI from running the scenarios through `cargo test` by default.

The `rstest-bdd` project[^1][^2] exposes Given-When-Then macros that register
steps alongside `rstest` fixtures and generate scenario tests with the regular
test harness. Migrating unlocks a single runner (`cargo test`), reduces the
amount of bespoke world state, and lets behaviour tests reuse the same
fixtures, dependency-injection pattern, and lint configuration already in place
for unit tests.

## Decision outcome (summary)

- Adopt `rstest-bdd` v0.3.2 for all behaviour tests.
- Keep the existing `.feature` files but execute them through scenario tests
  generated by `rstest-bdd` macros.
- Replace the monolithic `CliWorld` with focussed fixtures that expose the
  state required by each step.
- Remove the `cucumber` dependency, runner, and associated documentation once
  the new harness reaches parity.

## Goals and non-goals

- **Goals:**
  - Run every `.feature` via `cargo test`, ensuring CI exercises BDD coverage
    without a bespoke harness.
  - Share fixtures between unit tests and behaviour tests, removing duplicate
    plumbing for temporary directories, HTTP servers, manifest parsing, and
    stdlib rendering state.
  - Maintain or improve the readability of step definitions by leveraging the
    `rstest-bdd` placeholder syntax, structured docstrings, and scenario
    validation features.
  - Support the existing Unix-only scenarios by guarding the generated tests
    with the same `#[cfg(unix)]` expressions used today.
  - Provide clear documentation covering authoring, running, and extending the
    new harness.
- **Non-goals:**
  - Redesigning the feature files themselves; the migration focuses on the
    Rust harness and supporting fixtures.
  - Replacing the `test_support` helpers or the HTTP fixture implementation.
  - Introducing asynchronous step definitions; steps continue to run
    synchronously while scenarios may layer `#[tokio::test]` if required.

## Migration plan

### Phase 0 – Inventory and readiness

- Catalogue every `.feature` under `tests/features` and `tests/features_unix`,
  mapping them to their owning step modules (`cli_steps`, `manifest_steps`,
  `stdlib_steps`, and so on). Note usages of data tables, docstrings, scenario
  outlines, and tags to ensure equivalent support.
- Record the shared state currently held in `CliWorld` (CLI parsing artefacts,
  manifest IR, Ninja output, stdlib HTTP fixtures, environment guards) and
  decide which pieces belong in reusable fixtures versus per-step helpers.
- Confirm CI expectations: document the required runtime (Tokio multi-thread)
  and any ports that must stay bound/unbound before eliminating the Cucumber
  runner safeguards.

### Phase 1 – Harness foundation

- Add `rstest-bdd = "0.3.2"` and `rstest-bdd-macros = { version = "0.3.2",
  features = ["strict-compile-time-validation"]
  }` to the workspace `dev-dependencies`. Keep `rstest
  ` as the shared fixture provider.
- Introduce a `tests/bdd` module tree that will own scenario functions,
  feature-specific fixtures, and utilities for inserting values into the
  `StepContext`.
- Establish a small compatibility shim that makes feature paths available in a
  single location (for example, constants enumerating each `.feature` file) so
  both the migration branch and future contributors have one source of truth.
- Decide on the default attributes applied to generated tests (for example,
  stacking `#[scenario(...)]` with `#[tokio::test(flavor = "multi_thread")]`
  for steps that require Tokio). Document the pattern in
  `docs/rstest-bdd-users-guide.md`.

### Phase 2 – Fixture extraction and world bridging

- Refactor `CliWorld` into plain data holders (for example `CliState`,
  `ManifestState`, `StdlibState`, `ProcessState`) that expose the smallest
  mutable surface required by each step. Each holder lives in
  `tests/bdd/fixtures.rs` (or similar) and is backed by `Arc<Mutex<...>>` when
  interior mutability is required.
- Provide `#[rstest::fixture]` constructors for shared resources:
  - Temporary workspace plus `PathGuard` handling for PATH edits.
  - HTTP server guard that mirrors `start_http_server`/`shutdown_http_server`
    semantics.
  - CLI/manifest/ninja contexts seeded with sensible defaults.
- Implement helper APIs that update the fixture structs (for example,
  `CliState::record_parse_result`). Re-export them so both the cucumber steps
  and the new `rstest-bdd` steps can call the same logic during the migration
  window.
- Add a thin adapter that makes the fixture bundle available as a single
  `ScenarioState` struct for the remaining cucumber runner so the existing
  tests stay green while new scenario functions are introduced.

### Phase 3 – Feature ports (incremental)

Port features in self-contained slices so regressions stay localised. For each
slice, create `#[scenario]` functions, translate the step macros, and delete
the cucumber equivalents once the new tests pass.

#### 3A – CLI and manifest features

- Convert `tests/steps/cli_steps.rs` and `tests/steps/manifest_steps.rs` to use
  `rstest_bdd_macros::{given, when, then}`. Replace the `&mut CliWorld`
  parameter with explicit fixture references.
- Generate scenario tests per behaviour (`cli.feature`, `manifest.feature`) in
  `tests/bdd/cli.rs` and `tests/bdd/manifest.rs`. Use `#[scenario(name = ...)]`
  to keep the mapping explicit and ensure that multiple scenarios per feature
  are covered.
- Keep the original cucumber steps temporarily by moving the shared business
  logic into plain helper functions (for example, `fn record_cli_parse(...)`).
  Delete the cucumber wrappers once parity is confirmed.

#### 3B – IR and Ninja features

- Apply the same conversion to `ir_steps`, `ninja_steps`, and `process_steps`.
  Ensure fixtures expose the build graph, Ninja text, and process execution
  results.
- Where steps previously mutated `CliWorld` fields, replace them with explicit
  method calls on the new fixture structs to keep ownership clear.
- Add scenario modules (`tests/bdd/ir.rs`, `tests/bdd/ninja.rs`,
  `tests/bdd/process.rs`) and verify outline handling where Examples tables are
  used.

#### 3C – Stdlib and Unix-only features

- Split the large `stdlib_steps` module into thematic submodules capped at 400
  lines, exposing fixtures for stdlib templates, network policies, streaming
  buffers, and HTTP servers.
- Port the generic stdlib features first, then gate the Unix-only scenarios in
  `tests/features_unix` behind `#[cfg(unix)]` on their scenario functions so
  they mirror the current behaviour of the cucumber runner.
- Mirror the teardown guarantees currently implemented in `CliWorld::drop`
  by adding scoped fixtures that `impl Drop` to clean up HTTP servers, temp
  directories, and environment overrides.

#### 3D – Process execution and cross-cutting steps

- Move helpers from `tests/steps/common.rs` into a shared support module and
  port any remaining steps that feed into both CLI and stdlib scenarios.
- Run `cargo bdd steps`/`cargo bdd unused` to confirm that every step is
  exercised and that no stale macros remain registered.

### Phase 4 – Remove cucumber harness

- Delete `tests/cucumber.rs`, the `CliWorld` struct, and the `tests/steps`
  modules that only exist for cucumber.
- Remove `cucumber` (and `tokio` features added solely for the runner) from
  `Cargo.toml` along with the `[[test]]` entry that disables the default
  harness.
- Drop cucumber-specific documentation such as
  `docs/behavioural-testing-in-rust-with-cucumber.md` once rewritten, and
  update any references in the user guide and Orca/Ortho docs.

### Phase 5 – Documentation, CI, and enablement

- Update `docs/rstest-bdd-users-guide.md` with Netsuke-specific conventions
  (fixture layout, naming, and how to add new scenarios) discovered during the
  migration.
- Rewrite `docs/behavioural-testing-in-rust-with-cucumber.md` as an
  `rstest-bdd` guide or archive it with a clear note that cucumber is
  unsupported.
- Ensure `make test` executes the new scenarios by default and document the
  relevant `cargo test` filters (for example, `cargo test bdd::cli`).
- Capture the required developer tooling (`cargo bdd steps`, lint checks) in
  `docs/roadmap.md` and `docs/users-guide.md` so future work follows the new
  harness.

## Consequences and risks

### Positive outcomes

- Behaviour tests run through the standard harness, so `make test` exercises
  them alongside unit tests and inherits the existing CI parallelism.
- Fixtures become composable and discoverable; new behaviour tests can reuse
  `rstest` fixtures without inventing new world plumbing.
- The `rstest-bdd` validation features catch missing steps during compilation
  (with `strict-compile-time-validation`), preventing silent drift between the
  feature files and the Rust implementation.

### Risks and mitigations

- *Risk:* Rewriting every step macro creates churn and may introduce subtle
  regressions. *Mitigation:* Port features in small slices, keep cucumber
  running until each slice is validated, and rely on helpers shared between the
  old and new harnesses to avoid behavioural drift.
- *Risk:* The new fixture structs may not cover all the clean-up logic handled
  implicitly by `CliWorld::drop`. *Mitigation:* Model teardown as RAII helpers
  (`ScopeGuard`-style fixtures) and add explicit tests that assert destructors
  restore environment variables, stop HTTP servers, and delete temp files.
- *Risk:* Developers unfamiliar with `rstest-bdd` may struggle to add new
  scenarios. *Mitigation:* Expand the user guide with Netsuke-specific recipes
  and add a `cargo bdd` section to the contributor docs.

## Key differences from cucumber-rs

This section documents behavioural differences between `cucumber-rs` and
`rstest-bdd` discovered during migration planning. These observations are
intended as feedback for `rstest-bdd` developers and as guidance for teams
migrating existing cucumber test suites.

### 1. Quoted string capture includes delimiters

**Cucumber behaviour**: The `{string}` placeholder captures the *contents* of a
quoted string, stripping the surrounding quotes automatically.

```gherkin
Given the CLI is parsed with "build --file foo.yml"
```

```rust
// cucumber-rs step receives: build --file foo.yml
#[given(expr = "the CLI is parsed with {string}")]
fn parse_cli(world: &mut CliWorld, args: String) {
    // args == "build --file foo.yml" (no quotes)
}
```

**rstest-bdd behaviour**: Placeholders capture the *literal* text including any
quotes present in the step text.

```rust
// rstest-bdd step receives: "build --file foo.yml"
#[given("the CLI is parsed with {args}")]
fn parse_cli(cli_state: &mut CliState, args: String) {
    // args == "\"build --file foo.yml\"" (includes quotes)
    let args = strip_quotes(&args);
}
```

**Migration workaround**: Introduce a `strip_quotes()` helper:

```rust
/// Remove surrounding double quotes from a captured placeholder.
///
/// Cucumber's `{string}` placeholder strips quotes automatically, but
/// rstest-bdd captures them verbatim. This helper restores cucumber
/// semantics for migrated steps.
///
/// # Examples
///
/// ```
/// assert_eq!(strip_quotes("\"hello\""), "hello");
/// assert_eq!(strip_quotes("hello"), "hello");
/// assert_eq!(strip_quotes("\"\""), "");
/// ```
fn strip_quotes(s: &str) -> &str {
    s.strip_prefix('"')
        .and_then(|s| s.strip_suffix('"'))
        .unwrap_or(s)
}
```

**Recommendation for rstest-bdd**: Consider adding a `{string}` type hint that
mirrors cucumber's quote-stripping behaviour. This would enable drop-in
compatibility for existing feature files and reduce boilerplate in migrated
codebases. A possible implementation:

```rust
// Proposed: {name:string} type hint strips surrounding quotes
#[given("the CLI is parsed with {args:string}")]
fn parse_cli(cli_state: &mut CliState, args: String) {
    // args == "build --file foo.yml" (quotes stripped)
}
```

### 2. Scenario Outline placeholders are not substituted

**Cucumber behaviour**: Scenario Outline `<placeholder>` tokens are substituted
with values from the Examples table *before* step matching. Each example row
generates a separate scenario execution with concrete values.

```gherkin
Scenario Outline: Target flags default to false
  Given the manifest "tests/data/defaults.yml" is parsed
  Then the target <index> is not phony

  Examples:
    | index |
    | 1     |
    | 2     |
    | 3     |
```

```rust
// cucumber-rs: step is invoked three times with index = "1", "2", "3"
#[then(expr = "the target {int} is not phony")]
fn target_not_phony(world: &mut CliWorld, index: usize) { ... }
```

**rstest-bdd behaviour**: The `<placeholder>` syntax is not recognized as a
substitution marker. The step text is matched literally, causing step lookup to
fail.
<!-- markdownlint-disable MD028 -->

> **Note**: This represents a fundamental gap in Gherkin Scenario Outline
> support. Without placeholder substitution, parameterized scenarios cannot
> execute.

<!-- markdownlint-enable MD028 -->
**Migration workaround**: Convert Scenario Outlines to either:

1. **Explicit scenarios**: Duplicate the scenario for each example row (loses
   the DRY benefit of outlines).

2. **rstest parameterization**: Use `#[rstest]` with `#[case]` attributes on
   the scenario function, though this moves parameterization from Gherkin to
   Rust.

3. **Data tables in steps**: Where the outline tests a list of values, rewrite
   as a single scenario with a data table step.

**Recommendation for rstest-bdd**: Implement Scenario Outline support with
Examples table processing. The `#[scenario]` macro should:

1. Detect `Scenario Outline:` blocks in the parsed feature.
2. Extract the `Examples:` table(s) and their column headers.
3. For each row, substitute `<column>` placeholders in all step texts.
4. Generate one test function per example row (or use `#[rstest]` cases).

This is a high-priority enhancement for cucumber compatibility, as Scenario
Outlines are a core Gherkin construct for reducing test duplication.

### 3. Step macro differences

**Cucumber macros**: Steps use `#[given(expr = "...")]`,
`#[when(expr = "...")]`, `#[then(expr = "...")]` from the `cucumber` crate,
with the world type as the first parameter.

```rust
use cucumber::{given, when, then};

#[given(expr = "the manifest file {string} is parsed")]
fn parse_manifest(world: &mut CliWorld, path: String) { ... }

#[when(expr = "the manifest is checked")]
fn check_manifest(world: &mut CliWorld) { ... }

#[then(expr = "parsing succeeds")]
fn parsing_succeeds(world: &CliWorld) { ... }
```

**rstest-bdd macros**: Steps use `#[given("...")]`, `#[when("...")]`,
`#[then("...")]` from `rstest_bdd_macros`. Fixtures are injected by parameter
name rather than a single world object.

```rust
use rstest_bdd_macros::{given, when, then};

#[given("the manifest file {path} is parsed")]
fn parse_manifest(manifest_state: &mut ManifestState, path: String) { ... }

#[when("the manifest is checked")]
fn check_manifest(manifest_state: &ManifestState) { ... }

#[then("parsing succeeds")]
fn parsing_succeeds(manifest_state: &ManifestState) { ... }
```

**Key differences**:

| Aspect             | cucumber-rs                     | rstest-bdd                               |
| ------------------ | ------------------------------- | ---------------------------------------- |
| Attribute syntax   | `#[given(expr = "...")]`        | `#[given("...")]`                        |
| Import path        | `cucumber::{given, when, then}` | `rstest_bdd_macros::{given, when, then}` |
| World parameter    | First param is `&mut World`     | No implicit world; fixtures by name      |
| Placeholder syntax | `{string}`, `{int}`, `{float}`  | `{name}`, `{name:type}`                  |

**Migration pattern**: A systematic find-and-replace can convert most steps:

```rust
// Before (cucumber)
#[given(expr = "the CLI is parsed with {string}")]
fn parse_cli(world: &mut CliWorld, args: String) {
    world.cli = Some(parse(&args));
}

// After (rstest-bdd)
#[given("the CLI is parsed with {args}")]
fn parse_cli(cli_state: &mut CliState, args: String) {
    let args = strip_quotes(&args);
    cli_state.cli.set(parse(&args));
}
```

**Recommendation for rstest-bdd**: Document the macro syntax differences
prominently in migration guides. Consider supporting `expr = "..."` as an alias
for the pattern string to reduce mechanical changes during migration.

### 4. No automatic fixture injection from scenario parameters

**Cucumber behaviour**: The `World` struct is automatically constructed and
passed to every step. Steps share state through this single mutable reference.

```rust
#[derive(Debug, Default, World)]
pub struct CliWorld {
    pub cli: Option<Cli>,
    pub manifest: Option<Manifest>,
    // ... all scenario state in one struct
}

// Every step receives the same world instance
#[given(expr = "...")]
fn step_one(world: &mut CliWorld) { world.cli = Some(...); }

#[then(expr = "...")]
fn step_two(world: &CliWorld) { assert!(world.cli.is_some()); }
```

**rstest-bdd behaviour**: The `#[scenario]` macro generates a test function,
but fixtures declared as scenario parameters are not automatically available to
step functions. Steps must access shared state through an alternative mechanism.

**Migration workaround**: Use thread-local storage with a `with_world()` access
pattern:

```rust
use std::cell::RefCell;

thread_local! {
    static WORLD: RefCell<Option<TestWorld>> = const { RefCell::new(None) };
}

/// Execute a closure with mutable access to the thread-local world.
///
/// # Panics
///
/// Panics if called outside a scenario context or if the world is already
/// borrowed.
fn with_world<F, R>(f: F) -> R
where
    F: FnOnce(&mut TestWorld) -> R,
{
    WORLD.with(|cell| {
        let mut borrow = cell.borrow_mut();
        let world = borrow.as_mut().expect("no world in thread-local storage");
        f(world)
    })
}

/// Initialize the thread-local world for a scenario.
fn init_world(world: TestWorld) {
    WORLD.with(|cell| {
        *cell.borrow_mut() = Some(world);
    });
}

/// Clear the thread-local world after a scenario completes.
fn clear_world() {
    WORLD.with(|cell| {
        *cell.borrow_mut() = None;
    });
}

// Steps access state through the thread-local helper
#[given("the CLI is parsed with {args}")]
fn parse_cli(args: String) {
    with_world(|world| {
        let args = strip_quotes(&args);
        world.cli_state.cli.set(parse(&args));
    });
}

// Scenario function initializes and cleans up the world
#[scenario(path = "tests/features/cli.feature", name = "...")]
fn cli_scenario(world: TestWorld) {
    init_world(world);
    // ... steps execute via thread-local access ...
    clear_world();
}
```

**Limitations of this approach**:

- Adds boilerplate to every step function.
- Thread-local storage is error-prone (forgotten init/clear, nested scenarios).
- Loses the type safety of direct fixture injection.
- Cannot easily support parallel scenario execution within a thread.

#### Observed failure: state leakage under sequential test execution

During migration, a concrete failure mode was observed that demonstrates the
fragility of the thread-local workaround. The test
`stdlib_grep_filter_streams_large_output_to_a_temporary_file` passes when run
in isolation but fails when executed sequentially with other tests using
`cargo test --test-threads=1`.

**Symptom**: The template variable `text` is undefined during rendering,
causing the error:

```text
invalid operation: input value is undefined (in <string>:1)
```

**Scenario under test** (`tests/features/stdlib.feature`):

```gherkin
Scenario: grep filter streams large output to a temporary file
  Given the stdlib command output limit is 512 bytes
  And the stdlib command stream limit is 200000 bytes
  And the stdlib template text contains 32768 lines of "match"
  When I render the stdlib template "{{ text | grep('match', none, {'mode': 'tempfile'}) }}" using the stdlib text
  Then the stdlib output file has at least 190000 bytes
```

**Root cause analysis**: The workaround implementation uses thread names to
detect scenario boundaries and reset state:

```rust
// tests/bdd/fixtures/mod.rs

thread_local! {
    static WORLD: RefCell<Option<TestWorld>> = const { RefCell::new(None) };
    static CURRENT_SCENARIO: RefCell<Option<String>> = const { RefCell::new(None) };
}

fn current_scenario_name() -> Option<String> {
    std::thread::current().name().map(String::from)
}

fn should_reset_world() -> bool {
    let current = current_scenario_name();
    CURRENT_SCENARIO.with(|stored| {
        let stored_name = stored.borrow();
        match (&*stored_name, &current) {
            (None, _) => true,                                // No scenario recorded yet
            (Some(prev), Some(curr)) if prev != curr => true, // Different scenario
            _ => false,
        }
    })
}

pub fn with_world<R>(f: impl FnOnce(&TestWorld) -> R) -> R {
    let should_reset = should_reset_world();
    if should_reset {
        WORLD.with(|w| {
            let _ = w.borrow_mut().take(); // Drop old world
            *w.borrow_mut() = Some(TestWorld::default());
        });
        update_scenario_name();
    }
    // ...
}
```

When tests run with `--test-threads=1`, all scenarios execute on the same
thread but with different thread names (e.g.,
`features_scenarios::stdlib_grep_filter_extracts_matching_lines` followed by
`features_scenarios::stdlib_grep_filter_streams_large_output_to_a_temporary_file`).

The failure occurs because:

1. **Step execution order**: The `Given` step sets `world.stdlib_text` via
   `Slot::set()`, and the `When` step retrieves it via `Slot::get()`.

2. **Scenario boundary detection**: The `should_reset_world()` function
   correctly detects the new scenario name and resets the world to
   `TestWorld::default()`.

3. **State loss**: However, under certain test orderings, the `Slot<String>`
   for `stdlib_text` either:
   - Is not properly initialized after the reset, or
   - Has its value cleared by residual `Drop` logic from the previous world
     instance executing interleaved with the new scenario's step setup.

4. **Race condition**: The `Slot<T>` type (from `rstest-bdd`) uses interior
   mutability. When the old `TestWorld` is dropped (line:
   `let _ = w.borrow_mut().take()`), its `Drop` implementation runs, which
   includes `self.stdlib_text.clear()`. If step functions from the new scenario
   have already begun populating slots before this drop completes, state
   corruption occurs.

**Evidence**: The test passes reliably with parallel execution (default) and in
isolation, but fails deterministically with `--test-threads=1` when preceded by
`stdlib_grep_filter_extracts_matching_lines`. This indicates the failure is
order-dependent and related to clean-up/initialization timing.

**Relevant code paths**:

- `tests/bdd/fixtures/mod.rs:55-65` — `should_reset_world()` scenario detection
- `tests/bdd/fixtures/mod.rs:89-112` — `with_world()` reset and access logic
- `tests/bdd/fixtures/mod.rs:252-259` — `TestWorld::drop()` clean-up
- `tests/bdd/steps/stdlib/config.rs:27-38` — step setting `stdlib_text`
- `tests/bdd/steps/stdlib/rendering.rs:201-211` — step reading `stdlib_text`

**Why this matters for rstest-bdd**: This failure demonstrates that
thread-local state management is fundamentally unsuitable for BDD scenarios
where:

1. Multiple scenarios run sequentially on the same thread
2. State must be reliably isolated between scenarios
3. Cleanup logic in `Drop` implementations can race with new scenario setup

The cucumber-rs `World` model avoids this by passing the world as an explicit
parameter to each step, ensuring the lifetime is tied to the scenario function
scope rather than thread-local storage with manual reset detection.

**Recommendation for rstest-bdd**: This is the highest-impact improvement for
cucumber migration ergonomics. Consider one of these approaches:

1. **Implicit fixture injection**: Allow step functions to declare fixture
   parameters that are automatically resolved from the scenario's fixture set.

   ```rust
   // Proposed: fixtures injected by matching parameter name to scenario fixtures
   #[scenario(path = "tests/features/cli.feature")]
   fn cli_scenario(cli_state: CliState, manifest_state: ManifestState) {
       // Steps automatically receive these fixtures
   }

   #[given("the CLI is parsed with {args}")]
   fn parse_cli(cli_state: &mut CliState, args: String) {
       // cli_state is injected from scenario context
   }
   ```

2. **Context parameter**: Pass a `StepContext` that provides typed access to
   fixtures registered by the scenario.

   ```rust
   #[given("the CLI is parsed with {args}")]
   fn parse_cli(ctx: &mut StepContext, args: String) {
       let cli_state: &mut CliState = ctx.fixture_mut();
       // ...
   }
   ```

3. **World derive macro**: Provide a `#[derive(World)]` that generates the
   thread-local boilerplate, similar to cucumber's approach but integrated with
   rstest fixtures.

   ```rust
   #[derive(Default, World)]
   struct TestWorld {
       cli_state: CliState,
       manifest_state: ManifestState,
   }

   // Steps receive &mut TestWorld automatically
   #[given("the CLI is parsed with {args}")]
   fn parse_cli(world: &mut TestWorld, args: String) { ... }
   ```

Without automatic fixture injection, every migrated step requires manual
thread-local access, which significantly increases migration effort and
introduces runtime failure modes that cucumber's compile-time world binding
avoids.

## Summary of recommendations for rstest-bdd

The following enhancements would significantly improve migration ergonomics for
teams moving from `cucumber-rs`:

| Priority     | Feature                                     | Impact                                |
| ------------ | ------------------------------------------- | ------------------------------------- |
| **Critical** | Fixture injection in step functions         | Eliminates thread-local boilerplate   |
| **High**     | Scenario Outline with Examples substitution | Enables parameterized scenarios       |
| **Medium**   | `{string}` type hint with quote stripping   | Drop-in compatibility for quoted args |
| **Low**      | `expr = "..."` alias for step patterns      | Reduces mechanical migration changes  |

These improvements would reduce the migration effort from a near-complete
rewrite of step definitions to a more mechanical transformation, preserving the
investment in existing Gherkin feature files and step logic.

## References

[^1]: <https://github.com/leynos/rstest-bdd/tree/v0.3.2>
[^2]: `docs/rstest-bdd-users-guide.md`
