# ADR: Replace `cucumber-rs` with `rstest-bdd` for behavioural tests

## Status

Accepted – plan recorded on 18 November 2025 to guide the migration to
`rstest-bdd` v0.1.0.

## Context and problem statement

Behavioural coverage currently depends on `cucumber-rs` via the dedicated
`tests/cucumber.rs` runner. The suite relies on a bespoke `CliWorld` struct,
Tokio-specific bootstrapping, and a separate test target declared under
`[[test]]` in `Cargo.toml`. This isolates behaviour-driven development (BDD)
from the rest of the Rust test ecosystem, duplicates fixture plumbing that is
already provided by `rstest`, prevents parallel execution with the unit tests,
and keeps CI from running the scenarios through `cargo test` by default.

The `rstest-bdd` project[^1][^2] exposes Given-When-Then macros that register
steps alongside `rstest` fixtures and generate scenario tests with the regular
test harness. Migrating unlocks a single runner (`cargo test`), reduces the
amount of bespoke world state, and lets behaviour tests reuse the same
fixtures, dependency-injection pattern, and lint configuration already in place
for unit tests.

## Decision outcome (summary)

- Adopt `rstest-bdd` v0.1.0 for all behaviour tests.
- Keep the existing `.feature` files but execute them through scenario tests
  generated by `rstest-bdd` macros.
- Replace the monolithic `CliWorld` with focussed fixtures that expose the
  state required by each step.
- Remove the `cucumber` dependency, runner, and associated documentation once
  the new harness reaches parity.

## Goals and non-goals

- **Goals:**
  - Run every `.feature` via `cargo test`, ensuring CI exercises BDD coverage
    without a bespoke harness.
  - Share fixtures between unit tests and behaviour tests, removing duplicate
    plumbing for temporary directories, HTTP servers, manifest parsing, and
    stdlib rendering state.
  - Maintain or improve the readability of step definitions by leveraging the
    `rstest-bdd` placeholder syntax, structured docstrings, and scenario
    validation features.
  - Support the existing Unix-only scenarios by guarding the generated tests
    with the same `#[cfg(unix)]` expressions used today.
  - Provide clear documentation covering authoring, running, and extending the
    new harness.
- **Non-goals:**
  - Redesigning the feature files themselves; the migration focuses on the
    Rust harness and supporting fixtures.
  - Replacing the `test_support` helpers or the HTTP fixture implementation.
  - Introducing asynchronous step definitions; steps continue to run
    synchronously while scenarios may layer `#[tokio::test]` if required.

## Migration plan

### Phase 0 – Inventory and readiness

- Catalogue every `.feature` under `tests/features` and `tests/features_unix`,
  mapping them to their owning step modules (`cli_steps`, `manifest_steps`,
  `stdlib_steps`, and so on). Note usages of data tables, docstrings, scenario
  outlines, and tags to ensure equivalent support.
- Record the shared state currently held in `CliWorld` (CLI parsing artefacts,
  manifest IR, Ninja output, stdlib HTTP fixtures, environment guards) and
  decide which pieces belong in reusable fixtures versus per-step helpers.
- Confirm CI expectations: document the required runtime (Tokio multi-thread)
  and any ports that must stay bound/unbound before eliminating the Cucumber
  runner safeguards.

### Phase 1 – Harness foundation

- Add `rstest-bdd = "0.1.0"` and `rstest-bdd-macros = { version = "0.1.0",
  features = ["strict-compile-time-validation"]
  }` to the workspace `dev-dependencies`. Keep `rstest
  ` as the shared fixture provider.
- Introduce a `tests/bdd` module tree that will own scenario functions,
  feature-specific fixtures, and utilities for inserting values into the
  `StepContext`.
- Establish a small compatibility shim that makes feature paths available in a
  single location (for example, constants enumerating each `.feature` file) so
  both the migration branch and future contributors have one source of truth.
- Decide on the default attributes applied to generated tests (for example,
  stacking `#[scenario(...)]` with `#[tokio::test(flavor = "multi_thread")]`
  for steps that require Tokio). Document the pattern in
  `docs/rstest-bdd- users-guide.md`.

### Phase 2 – Fixture extraction and world bridging

- Refactor `CliWorld` into plain data holders (for example `CliState`,
  `ManifestState`, `StdlibState`, `ProcessState`) that expose the smallest
  mutable surface required by each step. Each holder lives in
  `tests/bdd/ fixtures.rs` (or similar) and is backed by `Arc<Mutex<...>>` when
  interior mutability is required.
- Provide `#[rstest::fixture]` constructors for shared resources:
  - Temporary workspace plus `PathGuard` handling for PATH edits.
  - HTTP server guard that mirrors `start_http_server`/`shutdown_http_server`
    semantics.
  - CLI/manifest/ninja contexts seeded with sensible defaults.
- Implement helper APIs that update the fixture structs (for example,
  `CliState::record_parse_result`). Re-export them so both the cucumber steps
  and the new `rstest-bdd` steps can call the same logic during the migration
  window.
- Add a thin adapter that makes the fixture bundle available as a single
  `ScenarioState` struct for the remaining cucumber runner so the existing
  tests stay green while new scenario functions are introduced.

### Phase 3 – Feature ports (incremental)

Port features in self-contained slices so regressions stay localised. For each
slice, create `#[scenario]` functions, translate the step macros, and delete
the cucumber equivalents once the new tests pass.

#### 3A – CLI and manifest features

- Convert `tests/steps/cli_steps.rs` and `tests/steps/manifest_steps.rs` to use
  `rstest_bdd_macros::{given, when, then}`. Replace the `&mut CliWorld`
  parameter with explicit fixture references.
- Generate scenario tests per behaviour (`cli.feature`, `manifest.feature`) in
  `tests/bdd/cli.rs` and `tests/bdd/manifest.rs`. Use `#[scenario(name = ...)]`
  to keep the mapping explicit and ensure that multiple scenarios per feature
  are covered.
- Keep the original cucumber steps temporarily by moving the shared business
  logic into plain helper functions (for example, `fn record_cli_parse(...)`).
  Delete the cucumber wrappers once parity is confirmed.

#### 3B – IR and Ninja features

- Apply the same conversion to `ir_steps`, `ninja_steps`, and `process_steps`.
  Ensure fixtures expose the build graph, Ninja text, and process execution
  results.
- Where steps previously mutated `CliWorld` fields, replace them with explicit
  method calls on the new fixture structs to keep ownership clear.
- Add scenario modules (`tests/bdd/ir.rs`, `tests/bdd/ninja.rs`,
  `tests/bdd/process.rs`) and verify outline handling where Examples tables are
  used.

#### 3C – Stdlib and Unix-only features

- Split the large `stdlib_steps` module into thematic submodules capped at 400
  lines, exposing fixtures for stdlib templates, network policies, streaming
  buffers, and HTTP servers.
- Port the generic stdlib features first, then gate the Unix-only scenarios in
  `tests/features_unix` behind `#[cfg(unix)]` on their scenario functions so
  they mirror the current behaviour of the cucumber runner.
- Mirror the teardown guarantees currently implemented in `CliWorld::drop`
  by adding scoped fixtures that `impl Drop` to clean up HTTP servers, temp
  directories, and environment overrides.

#### 3D – Process execution and cross-cutting steps

- Move helpers from `tests/steps/common.rs` into a shared support module and
  port any remaining steps that feed into both CLI and stdlib scenarios.
- Run `cargo bdd steps`/`cargo bdd unused` to confirm that every step is
  exercised and that no stale macros remain registered.

### Phase 4 – Remove cucumber harness

- Delete `tests/cucumber.rs`, the `CliWorld` struct, and the `tests/steps`
  modules that only exist for cucumber.
- Remove `cucumber` (and `tokio` features added solely for the runner) from
  `Cargo.toml` along with the `[[test]]` entry that disables the default
  harness.
- Drop cucumber-specific documentation such as `docs/behavioural-testing-in-
  rust-with-cucumber.md
  ` once rewritten, and update any references in the user guide and Orca/Ortho docs.

### Phase 5 – Documentation, CI, and enablement

- Update `docs/rstest-bdd-users-guide.md` with Netsuke-specific conventions
  (fixture layout, naming, and how to add new scenarios) discovered during the
  migration.
- Rewrite `docs/behavioural-testing-in-rust-with-cucumber.md` as an
  `rstest-bdd` guide or archive it with a clear note that cucumber is
  unsupported.
- Ensure `make test` executes the new scenarios by default and document the
  relevant `cargo test` filters (for example, `cargo test bdd::cli`).
- Capture the required developer tooling (`cargo bdd steps`, lint checks) in
  `docs/roadmap.md` and `docs/users-guide.md` so future work follows the new
  harness.

## Consequences and risks

### Positive outcomes

- Behaviour tests run through the standard harness, so `make test` exercises
  them alongside unit tests and inherits the existing CI parallelism.
- Fixtures become composable and discoverable; new behaviour tests can reuse
  `rstest` fixtures without inventing new world plumbing.
- The `rstest-bdd` validation features catch missing steps during compilation
  (with `strict-compile-time-validation`), preventing silent drift between the
  feature files and the Rust implementation.

### Risks and mitigations

- *Risk:* Rewriting every step macro creates churn and may introduce subtle
  regressions. *Mitigation:* Port features in small slices, keep cucumber
  running until each slice is validated, and rely on helpers shared between the
  old and new harnesses to avoid behavioural drift.
- *Risk:* The new fixture structs may not cover all the cleanup logic handled
  implicitly by `CliWorld::drop`. *Mitigation:* Model teardown as RAII helpers
  (`ScopeGuard`-style fixtures) and add explicit tests that assert destructors
  restore environment variables, stop HTTP servers, and delete temp files.
- *Risk:* Developers unfamiliar with `rstest-bdd` may struggle to add new
  scenarios. *Mitigation:* Expand the user guide with Netsuke-specific recipes
  and add a `cargo bdd` section to the contributor docs.

## References

[^1]: <https://github.com/leynos/rstest-bdd/tree/v0.1.0>
[^2]: `docs/rstest-bdd-users-guide.md`
