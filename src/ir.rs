//! Intermediate Representation structures.
//!
//! This module defines the backend-agnostic build graph used by Netsuke after
//! validation. The IR mirrors the conceptual model of Ninja without embedding
//! any Ninja-specific syntax.
//!
//! # Examples
//!
//! ```
//! use netsuke::ir::{Action, BuildGraph, BuildEdge};
//! use netsuke::ast::Recipe;
//! use std::path::PathBuf;
//!
//! let action = Action {
//!     recipe: Recipe::Command { command: "echo hi".into() },
//!     description: None,
//!     depfile: None,
//!     deps_format: None,
//!     pool: None,
//!     restat: false,
//! };
//! let mut graph = BuildGraph::default();
//! graph.actions.insert("a".into(), action);
//! graph.default_targets.push(PathBuf::from("hello"));
//! ```
//
use std::collections::HashMap;
use std::path::PathBuf;

/// The complete, static build graph.
#[derive(Debug, Default, Clone)]
pub struct BuildGraph {
    /// All unique actions in the build keyed by a stable hash.
    pub actions: HashMap<String, Action>,
    /// All target files to be built keyed by output path.
    pub targets: HashMap<PathBuf, BuildEdge>,
    /// Targets built when no explicit target is requested.
    pub default_targets: Vec<PathBuf>,
}

/// A reusable command analogous to a Ninja rule.
#[derive(Debug, Clone, PartialEq)]
pub struct Action {
    pub recipe: Recipe,
    pub description: Option<String>,
    pub depfile: Option<String>,
    pub deps_format: Option<String>,
    pub pool: Option<String>,
    pub restat: bool,
}

/// A single build statement connecting inputs to outputs.
#[derive(Debug, Clone, PartialEq)]
pub struct BuildEdge {
    /// Identifier of the [`Action`] used for this edge.
    pub action_id: String,
    /// Explicit inputs that trigger a rebuild when changed.
    pub inputs: Vec<PathBuf>,
    /// Outputs explicitly generated by the command.
    pub explicit_outputs: Vec<PathBuf>,
    /// Outputs implicitly generated by the command (Ninja `|`).
    pub implicit_outputs: Vec<PathBuf>,
    /// Order-only dependencies that do not trigger rebuilds (Ninja `||`).
    pub order_only_deps: Vec<PathBuf>,
    /// Always run the command even if the output exists.
    pub phony: bool,
    /// Run the command on every invocation regardless of timestamps.
    pub always: bool,
}

use crate::ast::{NetsukeManifest, Recipe, StringOrList};
use sha2::{Digest, Sha256};
use thiserror::Error;

/// Errors produced during IR generation.
#[derive(Debug, Error)]
pub enum IrGenError {
    #[error("rule '{rule_name}' referenced by target '{target_name}' was not found")]
    RuleNotFound {
        target_name: String,
        rule_name: String,
    },

    #[error("multiple rules per target are not supported for '{target_name}'")]
    MultipleRules { target_name: String },

    #[error("target output '{output}' defined multiple times")]
    DuplicateOutput { output: String },
}

impl BuildGraph {
    /// Transform a manifest into a [`BuildGraph`].
    ///
    /// # Errors
    ///
    /// Returns [`IrGenError`] when a referenced rule is missing or multiple
    /// rules are specified for a single target.
    pub fn from_manifest(manifest: &NetsukeManifest) -> Result<Self, IrGenError> {
        let mut graph = Self::default();
        let mut rule_map = HashMap::new();

        Self::process_rules(manifest, &mut graph.actions, &mut rule_map);
        Self::process_targets(manifest, &mut graph.actions, &mut graph.targets, &rule_map)?;
        Self::process_defaults(manifest, &mut graph.default_targets);

        Ok(graph)
    }

    fn process_rules(
        manifest: &NetsukeManifest,
        actions: &mut HashMap<String, Action>,
        rule_map: &mut HashMap<String, String>,
    ) {
        for rule in &manifest.rules {
            let hash = register_action(actions, rule.recipe.clone(), rule.description.clone());
            rule_map.insert(rule.name.clone(), hash);
        }
    }

    fn process_targets(
        manifest: &NetsukeManifest,
        actions: &mut HashMap<String, Action>,
        targets: &mut HashMap<PathBuf, BuildEdge>,
        rule_map: &HashMap<String, String>,
    ) -> Result<(), IrGenError> {
        for target in manifest.actions.iter().chain(&manifest.targets) {
            let outputs = to_paths(&target.name);
            let action_id = match &target.recipe {
                Recipe::Rule { rule } => {
                    let name = extract_single(rule).ok_or_else(|| IrGenError::MultipleRules {
                        target_name: get_target_display_name(&outputs),
                    })?;
                    rule_map
                        .get(name)
                        .cloned()
                        .ok_or_else(|| IrGenError::RuleNotFound {
                            target_name: get_target_display_name(&outputs),
                            rule_name: name.to_string(),
                        })?
                }
                Recipe::Command { .. } | Recipe::Script { .. } => {
                    register_action(actions, target.recipe.clone(), None)
                }
            };

            let edge = BuildEdge {
                action_id,
                inputs: to_paths(&target.sources),
                explicit_outputs: outputs.clone(),
                implicit_outputs: Vec::new(),
                order_only_deps: to_paths(&target.order_only_deps),
                phony: target.phony,
                always: target.always,
            };

            for out in outputs {
                if targets.contains_key(&out) {
                    return Err(IrGenError::DuplicateOutput {
                        output: out.display().to_string(),
                    });
                }
                targets.insert(out, edge.clone());
            }
        }
        Ok(())
    }

    fn process_defaults(manifest: &NetsukeManifest, defaults: &mut Vec<PathBuf>) {
        for name in &manifest.defaults {
            defaults.push(PathBuf::from(name));
        }
    }
}

fn register_action(
    actions: &mut HashMap<String, Action>,
    recipe: Recipe,
    description: Option<String>,
) -> String {
    let action = Action {
        recipe,
        description,
        depfile: None,
        deps_format: None,
        pool: None,
        restat: false,
    };
    let hash = hash_action(&action);
    actions.entry(hash.clone()).or_insert(action);
    hash
}

/// Computes a hash for an [`Action`].
///
/// Note: The hash depends on the order and formatting of the fields as they
/// are serialized. If stability across code or format changes is required,
/// consider using a canonical serialization format via `serde`.
fn hash_action(action: &Action) -> String {
    let mut hasher = Sha256::new();
    hash_recipe(&mut hasher, &action.recipe);
    hash_optional_fields(&mut hasher, action);
    format!("{:x}", hasher.finalize())
}

fn hash_recipe(hasher: &mut Sha256, recipe: &Recipe) {
    match recipe {
        Recipe::Command { command } => {
            hasher.update(b"cmd");
            update_with_len(hasher, command.as_bytes());
        }
        Recipe::Script { script } => {
            hasher.update(b"scr");
            update_with_len(hasher, script.as_bytes());
        }
        Recipe::Rule { rule } => {
            hasher.update(b"rule");
            hash_rule_reference(hasher, rule);
        }
    }
}

fn hash_optional_fields(hasher: &mut Sha256, action: &Action) {
    hash_optional_string(hasher, action.description.as_ref());
    hash_optional_string(hasher, action.depfile.as_ref());
    hash_optional_string(hasher, action.deps_format.as_ref());
    hash_optional_string(hasher, action.pool.as_ref());
    hasher.update(if action.restat { b"1" } else { b"0" });
}

fn hash_rule_reference(hasher: &mut Sha256, rule: &StringOrList) {
    match rule {
        StringOrList::String(r) => update_with_len(hasher, r.as_bytes()),
        StringOrList::List(list) => {
            for r in list {
                update_with_len(hasher, r.as_bytes());
            }
        }
        StringOrList::Empty => {}
    }
}

fn hash_optional_string(hasher: &mut Sha256, value: Option<&String>) {
    match value {
        Some(v) => {
            hasher.update(b"1");
            update_with_len(hasher, v.as_bytes());
        }
        None => hasher.update(b"0"),
    }
}

fn update_with_len(hasher: &mut Sha256, bytes: &[u8]) {
    let len = bytes.len();
    hasher.update(format!("{len}:").as_bytes());
    hasher.update(bytes);
}

fn to_paths(sol: &StringOrList) -> Vec<PathBuf> {
    match sol {
        StringOrList::Empty => Vec::new(),
        StringOrList::String(s) => vec![PathBuf::from(s)],
        StringOrList::List(v) => v.iter().map(PathBuf::from).collect(),
    }
}

fn extract_single(sol: &StringOrList) -> Option<&str> {
    match sol {
        StringOrList::String(s) => Some(s),
        StringOrList::List(v) if v.len() == 1 => v.first().map(String::as_str),
        _ => None,
    }
}

fn get_target_display_name(paths: &[PathBuf]) -> String {
    paths
        .first()
        .map(|p| p.display().to_string())
        .unwrap_or_default()
}

#[cfg(test)]
mod tests {
    use super::*;
    use rstest::rstest;

    #[rstest]
    #[case(
        Action {
            recipe: Recipe::Command { command: "echo".into() },
            description: Some("desc".into()),
            depfile: Some("$out.d".into()),
            deps_format: Some("gcc".into()),
            pool: None,
            restat: false,
        },
        "a0f6e2cd3b9b3cee0bf94a7d53bce56cf4178dfe907bb1cb7c832f47846baf38"
    )]
    #[case(
        Action {
            recipe: Recipe::Rule { rule: StringOrList::List(vec!["a".into(), "b".into()]) },
            description: None,
            depfile: None,
            deps_format: None,
            pool: None,
            restat: true,
        },
        "cf8e97357820acf6f66037dcf977ee36c88c2811d60342db30c99507d24a0d60"
    )]
    fn hash_action_is_stable(#[case] action: Action, #[case] expected: &str) {
        assert_eq!(hash_action(&action), expected);
    }
}
