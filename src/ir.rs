//! Intermediate Representation structures.
//!
//! This module defines the backend-agnostic build graph used by Netsuke after
//! validation. The IR mirrors the conceptual model of Ninja without embedding
//! any Ninja-specific syntax.
//!
//! # Examples
//!
//! ```
//! use netsuke::ir::{Action, BuildGraph, BuildEdge};
//! use netsuke::ast::Recipe;
//! use std::path::PathBuf;
//!
//! let action = Action {
//!     recipe: Recipe::Command { command: "echo hi".into() },
//!     description: None,
//!     depfile: None,
//!     deps_format: None,
//!     pool: None,
//!     restat: false,
//! };
//! let mut graph = BuildGraph::default();
//! graph.actions.insert("a".into(), action);
//! graph.default_targets.push(PathBuf::from("hello"));
//! ```
//
use std::collections::HashMap;
use std::path::{Path, PathBuf};

/// The complete, static build graph.
#[derive(Debug, Default, Clone)]
pub struct BuildGraph {
    /// All unique actions in the build keyed by a stable hash.
    pub actions: HashMap<String, Action>,
    /// All target files to be built keyed by output path.
    pub targets: HashMap<PathBuf, BuildEdge>,
    /// Targets built when no explicit target is requested.
    pub default_targets: Vec<PathBuf>,
}

/// A reusable command analogous to a Ninja rule.
use serde::Serialize;

#[derive(Debug, Clone, PartialEq, Serialize)]
pub struct Action {
    pub recipe: Recipe,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub depfile: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub deps_format: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pool: Option<String>,
    pub restat: bool,
}

/// A single build statement connecting inputs to outputs.
#[derive(Debug, Clone, PartialEq)]
pub struct BuildEdge {
    /// Identifier of the [`Action`] used for this edge.
    pub action_id: String,
    /// Explicit inputs that trigger a rebuild when changed.
    pub inputs: Vec<PathBuf>,
    /// Outputs explicitly generated by the command.
    pub explicit_outputs: Vec<PathBuf>,
    /// Outputs implicitly generated by the command (Ninja `|`).
    pub implicit_outputs: Vec<PathBuf>,
    /// Order-only dependencies that do not trigger rebuilds (Ninja `||`).
    pub order_only_deps: Vec<PathBuf>,
    /// Output does not correspond to a real file.
    pub phony: bool,
    /// Run the command on every invocation regardless of timestamps.
    pub always: bool,
}

use crate::ast::{NetsukeManifest, Recipe, Rule, StringOrList};
use shell_quote::{QuoteRefExt, Sh};
use std::sync::Arc;
use thiserror::Error;

use crate::hasher::ActionHasher;

/// Errors produced during IR generation.
#[derive(Debug, Error)]
pub enum IrGenError {
    #[error("rule '{rule_name}' referenced by target '{target_name}' was not found")]
    RuleNotFound {
        target_name: String,
        rule_name: String,
    },

    #[error("multiple rules for target '{target_name}': {rules:?}")]
    MultipleRules {
        target_name: String,
        rules: Vec<String>,
    },

    #[error("No rules specified for target {target_name}")]
    EmptyRule { target_name: String },

    #[error("duplicate target outputs: {outputs:?}")]
    DuplicateOutput { outputs: Vec<String> },

    #[error("circular dependency detected: {cycle:?}")]
    CircularDependency { cycle: Vec<PathBuf> },

    #[error("failed to serialise action: {0}")]
    ActionSerialisation(#[from] serde_json::Error),

    #[error("command is not a valid shell command: {snippet}")]
    InvalidCommand { command: String, snippet: String },
}

impl BuildGraph {
    /// Transform a manifest into a [`BuildGraph`].
    ///
    /// # Errors
    ///
    /// Returns [`IrGenError`] when a referenced rule is missing, multiple rules
    /// are specified for a single target, or no rule is provided.
    pub fn from_manifest(manifest: &NetsukeManifest) -> Result<Self, IrGenError> {
        let mut graph = Self::default();
        let mut rule_map: HashMap<String, Arc<Rule>> = HashMap::new();

        Self::process_rules(manifest, &mut rule_map);
        Self::process_targets(manifest, &mut graph.actions, &mut graph.targets, &rule_map)?;
        Self::process_defaults(manifest, &mut graph.default_targets);

        graph.detect_cycles()?;

        Ok(graph)
    }

    /// Collect rule templates without deduplicating them.
    ///
    /// Rules are stored verbatim and expanded later when targets reference
    /// them. This allows each target's input and output paths to be embedded in
    /// the resulting command, meaning identical rule definitions may yield
    /// distinct actions once interpolated. Should the manifest schema ever
    /// permit targets to override recipe fields such as `command` or
    /// `description`, those target-level values take precedence over the rule's
    /// defaults.
    fn process_rules(manifest: &NetsukeManifest, rule_map: &mut HashMap<String, Arc<Rule>>) {
        for rule in &manifest.rules {
            rule_map.insert(rule.name.clone(), Arc::new(rule.clone()));
        }
    }

    fn process_targets(
        manifest: &NetsukeManifest,
        actions: &mut HashMap<String, Action>,
        targets: &mut HashMap<PathBuf, BuildEdge>,
        rule_map: &HashMap<String, Arc<Rule>>,
    ) -> Result<(), IrGenError> {
        for target in manifest.actions.iter().chain(&manifest.targets) {
            let outputs = to_paths(&target.name);
            let inputs = to_paths(&target.sources);
            let target_name = get_target_display_name(&outputs);
            let action_id = match &target.recipe {
                Recipe::Rule { rule } => {
                    let tmpl = resolve_rule(rule, rule_map, &target_name)?;
                    // Future schema versions may allow targets to override
                    // recipe or description fields. If so, those values will
                    // take precedence over the rule template.
                    register_action(
                        actions,
                        tmpl.recipe.clone(),
                        tmpl.description.clone(),
                        &inputs,
                        &outputs,
                    )?
                }
                Recipe::Command { .. } | Recipe::Script { .. } => {
                    register_action(actions, target.recipe.clone(), None, &inputs, &outputs)?
                }
            };

            let edge = BuildEdge {
                action_id,
                inputs: inputs.clone(),
                explicit_outputs: outputs.clone(),
                implicit_outputs: Vec::new(),
                order_only_deps: to_paths(&target.order_only_deps),
                phony: target.phony,
                always: target.always,
            };

            if let Some(dups) = find_duplicates(&outputs, targets) {
                return Err(IrGenError::DuplicateOutput { outputs: dups });
            }
            for out in outputs {
                targets.insert(out, edge.clone());
            }
        }
        Ok(())
    }

    fn process_defaults(manifest: &NetsukeManifest, defaults: &mut Vec<PathBuf>) {
        for name in &manifest.defaults {
            defaults.push(PathBuf::from(name));
        }
    }

    fn detect_cycles(&self) -> Result<(), IrGenError> {
        if let Some(cycle) = find_cycle(&self.targets) {
            return Err(IrGenError::CircularDependency { cycle });
        }
        Ok(())
    }
}

/// Insert an action into the graph, deduplicating on the resolved command and
/// file set.
///
/// The rule template is interpolated with the target's inputs and outputs,
/// which are shell-escaped and embedded directly in the command. The resulting
/// [`Action`] is hashed so identical commands operating on the same file sets
/// share an identifier, while differing paths produce distinct actions even if
/// they originate from the same rule definition.
fn register_action(
    actions: &mut HashMap<String, Action>,
    recipe: Recipe,
    description: Option<String>,
    inputs: &[PathBuf],
    outputs: &[PathBuf],
) -> Result<String, IrGenError> {
    let recipe = match recipe {
        Recipe::Command { command } => {
            let interpolated = interpolate_command(&command, inputs, outputs)?;
            Recipe::Command {
                command: interpolated,
            }
        }
        other => other,
    };
    let action = Action {
        recipe,
        description,
        depfile: None,
        deps_format: None,
        pool: None,
        restat: false,
    };
    let hash = ActionHasher::hash(&action).map_err(IrGenError::ActionSerialisation)?;
    actions.entry(hash.clone()).or_insert(action);
    Ok(hash)
}

/// Returns `true` when the command contains an odd number of backticks.
///
/// # Examples
/// ```rust,ignore
/// assert!(has_unmatched_backticks("echo`"));
/// assert!(!has_unmatched_backticks("`echo`"));
/// ```
fn has_unmatched_backticks(s: &str) -> bool {
    s.chars().filter(|&c| c == '`').count().rem_euclid(2) != 0
}

fn interpolate_command(
    template: &str,
    inputs: &[PathBuf],
    outputs: &[PathBuf],
) -> Result<String, IrGenError> {
    fn quote_paths(paths: &[PathBuf]) -> Vec<String> {
        paths
            .iter()
            .map(|p| {
                let quoted_bytes: Vec<u8> = p.as_os_str().quoted(Sh);
                String::from_utf8_lossy(&quoted_bytes).into_owned()
            })
            .collect()
    }

    let ins = quote_paths(inputs);
    let outs = quote_paths(outputs);
    let interpolated = substitute(template, &ins, &outs);
    if has_unmatched_backticks(&interpolated) || shlex::split(&interpolated).is_none() {
        let snippet = interpolated.chars().take(160).collect();
        return Err(IrGenError::InvalidCommand {
            command: interpolated,
            snippet,
        });
    }
    Ok(interpolated)
}

/// Returns whether `ch` is a valid identifier character (ASCII letter, digit, or underscore).
///
/// # Examples
/// ```rust,ignore
/// assert!(is_identifier_char('a'));
/// assert!(!is_identifier_char('-'));
/// ```
fn is_identifier_char(ch: char) -> bool {
    ch.is_ascii_alphanumeric() || ch == '_'
}

/// Checks if `pattern` matches `chars` starting at `pos`.
///
/// # Examples
/// ```rust,ignore
/// let chars: Vec<char> = "in-out".chars().collect();
/// assert!(matches_pattern_at_position(&chars, 0, &['i', 'n']));
/// assert!(!matches_pattern_at_position(&chars, 3, &['i', 'n']));
/// ```
fn matches_pattern_at_position(chars: &[char], pos: usize, pattern: &[char]) -> bool {
    pattern
        .iter()
        .enumerate()
        .all(|(off, ch)| matches!(chars.get(pos + off), Some(c) if c == ch))
}

/// Ensures characters around the token are not identifier characters.
///
/// # Examples
/// ```rust,ignore
/// let chars: Vec<char> = "$in".chars().collect();
/// assert!(has_valid_word_boundaries(&chars, 0, 2));
/// let chars: Vec<char> = "$input".chars().collect();
/// assert!(!has_valid_word_boundaries(&chars, 0, 2));
/// ```
fn has_valid_word_boundaries(chars: &[char], pos: usize, len: usize) -> bool {
    let prev_ok = chars
        .get(pos.wrapping_sub(1))
        .is_none_or(|c| !is_identifier_char(*c));
    let next_ok = chars
        .get(pos + len + 1)
        .is_none_or(|c| !is_identifier_char(*c));
    prev_ok && next_ok
}

/// Returns the skip length when `pattern` matches at `pos`.
///
/// # Examples
/// ```rust,ignore
/// let chars: Vec<char> = "$in".chars().collect();
/// let res = try_match_placeholder(&chars, 0, &['i', 'n']);
/// assert_eq!(res, Some(3));
/// ```
fn try_match_placeholder(chars: &[char], pos: usize, pattern: &[char]) -> Option<usize> {
    if matches_pattern_at_position(chars, pos + 1, pattern)
        && has_valid_word_boundaries(chars, pos, pattern.len())
    {
        Some(pattern.len() + 1)
    } else {
        None
    }
}

/// Finds the appropriate substitution for `$in` or `$out` at `pos`.
///
/// # Examples
/// ```rust,ignore
/// let chars: Vec<char> = "$in".chars().collect();
/// let res = find_substitution(&chars, 0, "a", "");
/// assert_eq!(res, Some(("a", 3)));
/// ```
fn find_substitution<'a>(
    chars: &[char],
    pos: usize,
    ins: &'a str,
    outs: &'a str,
) -> Option<(&'a str, usize)> {
    try_match_placeholder(chars, pos, &['i', 'n'])
        .map(|skip| (ins, skip))
        .or_else(|| try_match_placeholder(chars, pos, &['o', 'u', 't']).map(|skip| (outs, skip)))
}

fn substitute(template: &str, ins: &[String], outs: &[String]) -> String {
    let chars: Vec<char> = template.chars().collect();
    let ins_joined = ins.join(" ");
    let outs_joined = outs.join(" ");
    let mut out = String::with_capacity(template.len());
    let mut i = 0;
    while let Some(&ch) = chars.get(i) {
        if ch == '$'
            && let Some((replacement, skip)) =
                find_substitution(&chars, i, &ins_joined, &outs_joined)
        {
            out.push_str(replacement);
            i += skip;
        } else {
            out.push(ch);
            i += 1;
        }
    }
    out
}

fn map_string_or_list<T, F>(sol: &StringOrList, f: F) -> Vec<T>
where
    F: Fn(&str) -> T,
{
    match sol {
        StringOrList::Empty => Vec::new(),
        StringOrList::String(s) => vec![f(s)],
        StringOrList::List(v) => v.iter().map(|s| f(s)).collect(),
    }
}

fn to_paths(sol: &StringOrList) -> Vec<PathBuf> {
    map_string_or_list(sol, |s| PathBuf::from(s))
}

fn to_string_vec(sol: &StringOrList) -> Vec<String> {
    map_string_or_list(sol, str::to_string)
}

fn extract_single(sol: &StringOrList) -> Option<&str> {
    match sol {
        StringOrList::String(s) => Some(s),
        StringOrList::List(v) if v.len() == 1 => v.first().map(String::as_str),
        _ => None,
    }
}

fn resolve_rule(
    rule: &StringOrList,
    rule_map: &HashMap<String, Arc<Rule>>,
    target_name: &str,
) -> Result<Arc<Rule>, IrGenError> {
    extract_single(rule).map_or_else(
        || {
            let mut rules = to_string_vec(rule);
            if rules.is_empty() {
                Err(IrGenError::EmptyRule {
                    target_name: target_name.to_string(),
                })
            } else {
                rules.sort();
                Err(IrGenError::MultipleRules {
                    target_name: target_name.to_string(),
                    rules,
                })
            }
        },
        |name| {
            rule_map
                .get(name)
                .cloned()
                .ok_or_else(|| IrGenError::RuleNotFound {
                    target_name: target_name.to_string(),
                    rule_name: name.to_string(),
                })
        },
    )
}

fn find_duplicates(
    outputs: &[PathBuf],
    targets: &HashMap<PathBuf, BuildEdge>,
) -> Option<Vec<String>> {
    let mut dups: Vec<_> = outputs
        .iter()
        .filter(|o| targets.contains_key(*o))
        .map(|o| o.display().to_string())
        .collect();
    if dups.is_empty() {
        None
    } else {
        dups.sort();
        Some(dups)
    }
}

fn get_target_display_name(paths: &[PathBuf]) -> String {
    paths
        .first()
        .map(|p| p.display().to_string())
        .unwrap_or_default()
}

#[derive(Clone, Copy)]
enum VisitState {
    Visiting,
    Visited,
}

fn should_visit_node<'a>(
    states: &mut HashMap<&'a Path, VisitState>,
    node: &'a Path,
) -> Result<bool, &'a Path> {
    match states.get(node) {
        Some(VisitState::Visited) => Ok(false),
        Some(VisitState::Visiting) => Err(node),
        None => {
            states.insert(node, VisitState::Visiting);
            Ok(true)
        }
    }
}

/// Detects cycles in a dependency graph by tracking traversal state.
struct CycleDetector<'a> {
    targets: &'a HashMap<PathBuf, BuildEdge>,
    stack: Vec<&'a Path>,
    states: HashMap<&'a Path, VisitState>,
}

impl<'a> CycleDetector<'a> {
    fn new(targets: &'a HashMap<PathBuf, BuildEdge>) -> Self {
        Self {
            targets,
            stack: Vec::new(),
            states: HashMap::new(),
        }
    }

    fn is_visited(&self, node: &Path) -> bool {
        matches!(self.states.get(node), Some(VisitState::Visited))
    }

    fn visit_node(&mut self, node: &'a Path) -> Option<Vec<PathBuf>> {
        match should_visit_node(&mut self.states, node) {
            Ok(false) => return None,
            Err(path) => {
                if let Some(idx) = self.stack.iter().position(|n| *n == path) {
                    let mut cycle: Vec<PathBuf> = self
                        .stack
                        .get(idx..)
                        .expect("slice")
                        .iter()
                        .map(|p| (*p).to_path_buf())
                        .collect();
                    cycle.push(path.to_path_buf());
                    return Some(canonicalize_cycle(cycle));
                }
                return Some(vec![path.to_path_buf(), path.to_path_buf()]);
            }
            Ok(true) => {}
        }

        self.stack.push(node);

        if let Some(edge) = self.targets.get(node)
            && let Some(cycle) = self.visit_dependencies(&edge.inputs)
        {
            return Some(cycle);
        }

        self.stack.pop();
        self.states.insert(node, VisitState::Visited);
        None
    }

    fn visit_dependencies(&mut self, deps: &'a [PathBuf]) -> Option<Vec<PathBuf>> {
        for dep in deps {
            if let Some(&head) = self.stack.last()
                && head == dep.as_path()
            {
                return Some(canonicalize_cycle(vec![dep.clone(), dep.clone()]));
            }

            if !self.targets.contains_key(dep) {
                continue;
            }

            if let Some(cycle) = self.visit_node(dep) {
                return Some(cycle);
            }
        }
        None
    }
}

fn find_cycle(targets: &HashMap<PathBuf, BuildEdge>) -> Option<Vec<PathBuf>> {
    // CycleDetector borrows paths from `targets`; `targets` must remain
    // unmodified during detection to keep borrowed keys valid.
    let mut detector = CycleDetector::new(targets);

    for node in targets.keys() {
        // Skip nodes we've already processed to avoid redundant traversal.
        if detector.is_visited(node) {
            continue;
        }
        if let Some(cycle) = detector.visit_node(node) {
            return Some(cycle);
        }
    }
    None
}

fn canonicalize_cycle(mut cycle: Vec<PathBuf>) -> Vec<PathBuf> {
    if cycle.len() < 2 {
        return cycle;
    }
    let len = cycle.len() - 1;
    let start = cycle
        .iter()
        .take(len)
        .enumerate()
        .min_by(|(_, a), (_, b)| a.cmp(b))
        .map_or(0, |(idx, _)| idx);
    if let Some(slice) = cycle.get_mut(..len) {
        slice.rotate_left(start);
    }
    if let (Some(first), Some(slot)) = (cycle.first().cloned(), cycle.get_mut(len)) {
        slot.clone_from(&first);
    }
    cycle
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn find_cycle_identifies_cycle() {
        let mut targets = HashMap::new();
        let edge_a = BuildEdge {
            action_id: "id".into(),
            inputs: vec![PathBuf::from("b")],
            explicit_outputs: vec![PathBuf::from("a")],
            implicit_outputs: Vec::new(),
            order_only_deps: Vec::new(),
            phony: false,
            always: false,
        };
        let edge_b = BuildEdge {
            action_id: "id".into(),
            inputs: vec![PathBuf::from("a")],
            explicit_outputs: vec![PathBuf::from("b")],
            implicit_outputs: Vec::new(),
            order_only_deps: Vec::new(),
            phony: false,
            always: false,
        };
        targets.insert(PathBuf::from("a"), edge_a);
        targets.insert(PathBuf::from("b"), edge_b);

        let cycle = find_cycle(&targets).expect("cycle");
        let option_a = vec![PathBuf::from("a"), PathBuf::from("b"), PathBuf::from("a")];
        let option_b = vec![PathBuf::from("b"), PathBuf::from("a"), PathBuf::from("b")];
        assert!(cycle == option_a || cycle == option_b);
    }

    #[test]
    fn canonicalize_cycle_rotates_smallest_node() {
        let cycle = vec![
            PathBuf::from("c"),
            PathBuf::from("a"),
            PathBuf::from("b"),
            PathBuf::from("c"),
        ];
        let canonical = canonicalize_cycle(cycle);
        let expected = vec![
            PathBuf::from("a"),
            PathBuf::from("b"),
            PathBuf::from("c"),
            PathBuf::from("a"),
        ];
        assert_eq!(canonical, expected);
    }

    #[test]
    fn canonicalize_cycle_handles_reverse_direction() {
        let cycle = vec![
            PathBuf::from("c"),
            PathBuf::from("b"),
            PathBuf::from("a"),
            PathBuf::from("c"),
        ];
        let canonical = canonicalize_cycle(cycle);
        let expected = vec![
            PathBuf::from("a"),
            PathBuf::from("c"),
            PathBuf::from("b"),
            PathBuf::from("a"),
        ];
        assert_eq!(canonical, expected);
    }
}
