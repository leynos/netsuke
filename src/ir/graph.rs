//! Build graph data structures and manifest conversion helpers.

use camino::Utf8PathBuf;
use serde::Serialize;
use std::collections::HashMap;
use thiserror::Error;

use crate::ast::Recipe;

/// The complete, static build graph.
#[derive(Debug, Default, Clone)]
pub struct BuildGraph {
    /// All unique actions in the build keyed by a stable hash.
    pub actions: HashMap<String, Action>,
    /// All target files to be built keyed by output path.
    pub targets: HashMap<Utf8PathBuf, BuildEdge>,
    /// Targets built when no explicit target is requested.
    pub default_targets: Vec<Utf8PathBuf>,
}

/// A reusable command analogous to a Ninja rule.

#[derive(Debug, Clone, PartialEq, Serialize)]
pub struct Action {
    pub recipe: Recipe,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub description: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub depfile: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub deps_format: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub pool: Option<String>,
    pub restat: bool,
}

/// A single build statement connecting inputs to outputs.
#[derive(Debug, Clone, PartialEq)]
pub struct BuildEdge {
    /// Identifier of the [`Action`] used for this edge.
    pub action_id: String,
    /// Explicit inputs that trigger a rebuild when changed.
    pub inputs: Vec<Utf8PathBuf>,
    /// Outputs explicitly generated by the command.
    pub explicit_outputs: Vec<Utf8PathBuf>,
    /// Outputs implicitly generated by the command (Ninja `|`).
    pub implicit_outputs: Vec<Utf8PathBuf>,
    /// Order-only dependencies that do not trigger rebuilds (Ninja `||`).
    pub order_only_deps: Vec<Utf8PathBuf>,
    /// Output does not correspond to a real file.
    pub phony: bool,
    /// Run the command on every invocation regardless of timestamps.
    pub always: bool,
}

/// Errors produced during IR generation.
///
/// Each variant documents a distinct validation failure encountered while
/// constructing the intermediate representation from a manifest.
///
/// # Examples
///
/// ```
/// use netsuke::ir::IrGenError;
///
/// fn describe(err: IrGenError) -> String {
///     match err {
///         IrGenError::EmptyRule { target_name } => {
///             format!("{target_name} missing rule")
///         },
///         other => other.to_string(),
///     }
/// }
///
/// assert_eq!(
///     describe(IrGenError::EmptyRule {
///         target_name: "app".into(),
///     }),
///     "app missing rule"
/// );
/// ```
#[derive(Debug, Error)]
pub enum IrGenError {
    /// Raised when a target references a rule that is not defined in the
    /// manifest.
    ///
    /// ```
    /// use netsuke::ir::IrGenError;
    ///
    /// let err = IrGenError::RuleNotFound {
    ///     target_name: "app".into(),
    ///     rule_name: "compile".into(),
    /// };
    /// assert!(matches!(
    ///     err,
    ///     IrGenError::RuleNotFound { rule_name, .. }
    ///         if rule_name == "compile"
    /// ));
    /// ```
    #[error("rule '{rule_name}' referenced by target '{target_name}' was not found")]
    RuleNotFound {
        target_name: String,
        rule_name: String,
    },

    /// Triggered when multiple rule names are supplied for a single target.
    ///
    /// ```
    /// use netsuke::ir::IrGenError;
    ///
    /// let err = IrGenError::MultipleRules {
    ///     target_name: "lib".into(),
    ///     rules: vec!["c".into(), "cpp".into()],
    /// };
    /// if let IrGenError::MultipleRules { rules, .. } = err {
    ///     assert_eq!(
    ///         rules,
    ///         vec!["c".to_string(), "cpp".to_string()]
    ///     );
    /// }
    /// ```
    #[error("multiple rules for target '{target_name}': {rules:?}")]
    MultipleRules {
        target_name: String,
        rules: Vec<String>,
    },

    /// Returned when a target declares no rule at all.
    ///
    /// ```
    /// use netsuke::ir::IrGenError;
    ///
    /// let err = IrGenError::EmptyRule { target_name: "docs".into() };
    /// assert_eq!(
    ///     err.to_string(),
    ///     "No rules specified for target docs"
    /// );
    /// ```
    #[error("No rules specified for target {target_name}")]
    EmptyRule { target_name: String },

    /// Indicates that more than one build edge produces the same output file.
    ///
    /// ```
    /// use netsuke::ir::IrGenError;
    ///
    /// let err = IrGenError::DuplicateOutput {
    ///     outputs: vec!["obj.o".into()],
    /// };
    /// if let IrGenError::DuplicateOutput { outputs } = err {
    ///     assert_eq!(
    ///         outputs,
    ///         vec!["obj.o".to_string()]
    ///     );
    /// }
    /// ```
    #[error("duplicate target outputs: {outputs:?}")]
    DuplicateOutput { outputs: Vec<String> },

    /// Emitted when a cycle exists in the target graph.
    ///
    /// ```
    /// use camino::Utf8PathBuf;
    /// use netsuke::ir::IrGenError;
    ///
    /// let err = IrGenError::CircularDependency {
    ///     cycle: vec![Utf8PathBuf::from("a"), Utf8PathBuf::from("a")],
    ///     missing_dependencies: Vec::new(),
    /// };
    /// if let IrGenError::CircularDependency { cycle, .. } = err {
    ///     assert_eq!(
    ///         cycle,
    ///         vec![Utf8PathBuf::from("a"), Utf8PathBuf::from("a")]
    ///     );
    /// }
    /// ```
    #[error("circular dependency detected: {cycle:?}")]
    CircularDependency {
        cycle: Vec<Utf8PathBuf>,
        missing_dependencies: Vec<(Utf8PathBuf, Utf8PathBuf)>,
    },

    /// Wraps failures encountered while serialising an action to JSON.
    ///
    /// ```
    /// use netsuke::ir::IrGenError;
    ///
    /// let source = serde_json::Error::custom("invalid action");
    /// let err = IrGenError::ActionSerialisation(source);
    /// assert!(err.to_string().contains("invalid action"));
    /// ```
    #[error("failed to serialise action: {0}")]
    ActionSerialisation(#[from] serde_json::Error),

    /// Raised when command interpolation yields an invalid shell snippet.
    ///
    /// ```
    /// use netsuke::ir::IrGenError;
    ///
    /// let err = IrGenError::InvalidCommand {
    ///     command: "echo $in".into(),
    ///     snippet: "echo $in".into(),
    /// };
    /// assert_eq!(
    ///     err.to_string(),
    ///     "command is not a valid shell command: echo $in"
    /// );
    /// ```
    #[error("command is not a valid shell command: {snippet}")]
    InvalidCommand { command: String, snippet: String },
}
